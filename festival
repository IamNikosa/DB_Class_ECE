/* DDL ξεκινω να οριζω τις οντοτητες και δε βαζω καθολου κλειδια, μονο τ attributes για αρχη. 
Αυριο θα κανω σε χαρτι το σχημα να δω ποιες σχεσεις περιττευουν και τοτε θα φτιαξω εδω τους 
πινακες των σχεσεων και θα βαλω κλειδια
 */
DROP DATABASE IF EXISTS fest;
CREATE DATABASE fest;
USE fest;

-- Create Location table 
CREATE TABLE Location (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Latitude DECIMAL(9,6) NOT NULL,
    Longitude DECIMAL(9,6) NOT NULL,
    Address VARCHAR(100) NOT NULL,
    City VARCHAR(100) NOT NULL,
    Country VARCHAR(100) NOT NULL,
    Continent VARCHAR(100) NOT NULL,
    UNIQUE (Latitude, Longitude),
    UNIQUE (Address, City, Country, Continent)
);

-- Create Stage table (renamed the second Stage table to Performer_Stage)
CREATE TABLE Stage (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Description VARCHAR(255),
    Capacity INT NOT NULL,
    Tech_Info VARCHAR(255) NOT NULL
);

-- Create Festival table
CREATE TABLE Festival (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Start_Date DATE NOT NULL,
    End_Date DATE NOT NULL,
    Location_ID INT NOT NULL,
    UNIQUE (Location_ID),
    UNIQUE (Start_Date),
    FOREIGN KEY (Location_ID) REFERENCES Location(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

-- Create Event table (Removed PERIOD FOR syntax)
CREATE TABLE Event (
    ID INT PRIMARY KEY,
    Start_Time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    End_Time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    Sold_Out BOOLEAN NOT NULL,
    Festival_ID INT NOT NULL,
    Stage_ID INT NOT NULL,
    UNIQUE (Festival_ID, Stage_ID, Start_Time),
    FOREIGN KEY (Festival_ID) REFERENCES Festival(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Stage_ID) REFERENCES Stage(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

-- Create Performer table
CREATE TABLE Performer (
    ID INT PRIMARY KEY,
    Real_Name VARCHAR(100),
    Stage_Name VARCHAR(100) NOT NULL,
    Birthday DATE,
    Instagram VARCHAR(100),
    Website VARCHAR(100),
    Is_Band BOOLEAN NOT NULL,
    Formation_Date DATE
);

CREATE TABLE Performance (
    ID INT PRIMARY KEY,
    Type VARCHAR(100) NOT NULL CHECK (Type IN ('Warm up', 'Head line', 'Special guest')),
    Start_Time TIME NOT NULL,
    Duration INT NOT NULL CHECK (Duration > 0 AND Duration <= 180),
    Performer_ID INT NOT NULL,
    Event_ID INT NOT NULL,
    UNIQUE (Event_ID, Performer_ID),
    FOREIGN KEY (Performer_ID) REFERENCES Performer(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Event_ID) REFERENCES Event(ID) ON DELETE CASCADE ON UPDATE CASCADE
);


-- Create Staff table
CREATE TABLE Staff (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Age INT NOT NULL CHECK (Age > 0),
    Type VARCHAR(100) NOT NULL CHECK (Type IN ('Trainee', 'Beginner', 'Intermediate', 'Experienced', 'Very Experienced'))
);

CREATE TABLE Support_Staff (
    Staff_ID INT PRIMARY KEY,
    FOREIGN KEY (Staff_ID) REFERENCES Staff(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE Security_Staff (
    Staff_ID INT PRIMARY KEY,
    FOREIGN KEY (Staff_ID) REFERENCES Staff(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE Technical_Staff (
    Staff_ID INT PRIMARY KEY,
    FOREIGN KEY (Staff_ID) REFERENCES Staff(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

-- Membership table: Artist is member of Band
CREATE TABLE Membership (
    Band_ID INT NOT NULL,
    Artist_ID INT NOT NULL,
    Join_Date DATE,
    PRIMARY KEY (Band_ID, Artist_ID),
    FOREIGN KEY (Band_ID) REFERENCES Performer(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Artist_ID) REFERENCES Performer(ID) ON DELETE CASCADE ON UPDATE CASCADE
);


-- Create Genre table 
CREATE TABLE Genre (
    ID INT PRIMARY KEY,
    Name VARCHAR(100)
);


-- Optional: Subgenre table
CREATE TABLE Subgenre (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Genre_ID INT NOT NULL,
    FOREIGN KEY (Genre_ID) REFERENCES Genre(ID) ON DELETE CASCADE ON UPDATE CASCADE
);



-- Optional: Performer's Subgenres (many-to-many)
CREATE TABLE Performer_Subgenre (
    Performer_ID INT NOT NULL,
    Subgenre_ID INT NOT NULL,
    PRIMARY KEY (Performer_ID, Subgenre_ID),
    FOREIGN KEY (Performer_ID) REFERENCES Performer(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Subgenre_ID) REFERENCES Subgenre(ID) ON DELETE CASCADE ON UPDATE CASCADE
);


-- Create event_staff table 
-- (Event is not null even though there is not full participation of staff in the relation.
--  This happens because unemployed staff members are not mentioned in any tupple participating in the relationship,
--  due to on delete cascade constraint. So in order to detect unemployed staff members we simply search for them in 
--  the relationship table.)
CREATE TABLE event_staff (
    Staff_ID INT NOT NULL,
    Event_ID INT NOT NULL,
    PRIMARY KEY (Staff_ID, Event_ID),
    FOREIGN KEY (Staff_ID) REFERENCES Staff(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Event_ID) REFERENCES Event(ID) ON DELETE CASCADE ON UPDATE CASCADE
);


-------------------------------------------------------------------------------------------------------------------
---------------------   T R I G G E R S ---------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------

-- Create trigger: FESTIVAL CANNOT BE CANCELDED
DELIMITER $$

CREATE TRIGGER prevent_festival_cancellation
BEFORE UPDATE ON Festival
FOR EACH ROW
BEGIN
    -- Prevent the cancellation of festivals
    IF OLD.End_Date IS NOT NULL AND NEW.End_Date IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Festivals cannot be canceled.';
    END IF;
END $$

DELIMITER ;


-- Create trigger: EVENT CANNOT BE CANCELLED
DELIMITER $$

CREATE TRIGGER prevent_event_cancellation
BEFORE UPDATE ON Event
FOR EACH ROW
BEGIN
    -- Prevent the cancellation of events
    IF NEW.Sold_Out = FALSE AND OLD.Sold_Out = TRUE THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Events cannot be canceled once they are marked as sold out.';
    END IF;
END $$

DELIMITER ;


DELIMITER $$

CREATE TRIGGER prevent_band_as_member
BEFORE INSERT ON Membership
FOR EACH ROW
BEGIN
    DECLARE is_band_member BOOLEAN;

    -- Check if the performer being added as a member is a band
    SELECT Is_Band INTO is_band_member
    FROM Performer
    WHERE ID = NEW.Artist_ID;

    -- If the member is a band, prevent the insertion
    IF is_band_member = TRUE THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'A band cannot be a member of another band.';
    END IF;
END$$

DELIMITER ;


-- Create trigger for SECURITY STAFF
DELIMITER $$

CREATE TRIGGER ensure_security_staff
BEFORE INSERT ON event_staff
FOR EACH ROW
BEGIN
    DECLARE total_capacity INT;
    DECLARE security_count INT;

    -- Get the total capacity of the stage for the event
    SELECT Capacity INTO total_capacity
    FROM Stage
    WHERE ID = (SELECT Stage_ID FROM Event WHERE ID = NEW.Event_ID);

    -- Get the count of security staff for the event
    SELECT COUNT(*) INTO security_count
    FROM event_staff es
    JOIN Security_Staff ss ON es.Staff_ID = ss.Staff_ID
    WHERE es.Event_ID = NEW.Event_ID;

    -- Ensure there are at least 5% security staff
    IF security_count < (total_capacity * 0.05) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Security staff should be at least 5% of the total capacity.';
    END IF;
END $$

DELIMITER ;

-- Create trigger for SUPPORT STAFF
DELIMITER $$

CREATE TRIGGER ensure_support_staff
BEFORE INSERT ON event_staff
FOR EACH ROW
BEGIN
    DECLARE total_capacity INT;
    DECLARE support_count INT;

    -- Get the total capacity of the stage for the event
    SELECT Capacity INTO total_capacity
    FROM Stage
    WHERE ID = (SELECT Stage_ID FROM Event WHERE ID = NEW.Event_ID);

    -- Get the count of support staff for the event
    SELECT COUNT(*) INTO support_count
    FROM event_staff es
    JOIN Support_Staff ss ON es.Staff_ID = ss.Staff_ID
    WHERE es.Event_ID = NEW.Event_ID;

    -- Ensure there are at least 2% support staff
    IF support_count < (total_capacity * 0.02) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Support staff should be at least 2% of the total capacity.';
    END IF;
END $$

DELIMITER ;


-- Create trigger for INTERVALS (from 5 to 30 mins) 
-- between consecutive performances of the same event
DELIMITER $$

CREATE TRIGGER check_performance_break
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE last_end_time TIME;
    DECLARE time_diff INT;

    -- Get the end time of the last performance in the event for the same stage
    SELECT End_Time INTO last_end_time
    FROM Performance
    WHERE Event_ID = NEW.Event_ID
      AND Performer_ID != NEW.Performer_ID
    ORDER BY End_Time DESC LIMIT 1;

    -- If a performance already exists, check the time difference
    IF last_end_time IS NOT NULL THEN
        SET time_diff = TIMESTAMPDIFF(MINUTE, last_end_time, NEW.Start_Time);

        -- Check if the break is between 5 and 30 minutes
        IF time_diff < 5 OR time_diff > 30 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'There must be a break between 5 and 30 minutes between performances.';
        END IF;
    END IF;
END $$

DELIMITER ;


-- Create trigger: NO OVERLAP OF EVENTS AT THE SAME STAGE
DELIMITER $$

CREATE TRIGGER prevent_stage_overlap
BEFORE INSERT ON Event
FOR EACH ROW
BEGIN
    DECLARE overlap_found INT;

    -- Check for overlap
    SELECT COUNT(*)
    INTO overlap_found
    FROM Event p
    WHERE p.Stage_ID = NEW.Stage_ID
      AND (
           (NEW.Start_Time BETWEEN p.Start_Time AND p.End_Time)
        OR (NEW.End_Time BETWEEN p.Start_Time AND p.End_Time)
        OR (p.Start_Time BETWEEN NEW.Start_Time AND NEW.End_Time)
        OR (p.End_Time BETWEEN NEW.Start_Time AND NEW.End_Time)
      );

    -- If overlap is found, signal an error
    IF overlap_found > 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Stage already occupied during this time.';
    END IF;
END $$

DELIMITER;


-- Create trigger: NO DOUBLE BOOKING OF PERFORMERS
DELIMITER $$

CREATE TRIGGER prevent_overlapping_performances
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE new_start TIME;
    DECLARE new_end TIME;

    SET new_start = NEW.Start_Time;
    SET new_end = ADDTIME(NEW.Start_Time, SEC_TO_TIME(NEW.Duration * 60));

    -- 1. Same performer overlap check
    IF EXISTS (
        SELECT 1
        FROM Performance p
        WHERE p.Performer_ID = NEW.Performer_ID
          AND p.Event_ID != NEW.Event_ID
          AND (
                (new_start BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (new_end BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (p.Start_Time BETWEEN new_start AND new_end)
             OR (ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)) BETWEEN new_start AND new_end)
          )
    ) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Performer is already in a performance during this time.';
    END IF;

    -- 2. Artist’s bands overlap
    IF EXISTS (
        SELECT 1
        FROM Membership m
        JOIN Performance p ON p.Performer_ID = m.Band_ID
        WHERE m.Artist_ID = NEW.Performer_ID
          AND (
                (new_start BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (new_end BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (p.Start_Time BETWEEN new_start AND new_end)
             OR (ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)) BETWEEN new_start AND new_end)
          )
    ) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'One of the performer’s bands is already performing during this time.';
    END IF;

    -- 3. Band member overlap
    IF EXISTS (
        SELECT 1
        FROM Membership m
        JOIN Performance p ON p.Performer_ID = m.Artist_ID
        WHERE m.Band_ID = NEW.Performer_ID
          AND (
                (new_start BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (new_end BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (p.Start_Time BETWEEN new_start AND new_end)
             OR (ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)) BETWEEN new_start AND new_end)
          )
    ) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'A member of the band is already performing during this time.';
    END IF;
END $$

DELIMITER ;


-- Create trigger: AFTER DELETION OF PERFRORMANCE
DELIMITER $$

CREATE TRIGGER after_performance_delete
AFTER DELETE ON Performance
FOR EACH ROW
BEGIN
    -- Call the procedure to reschedule performances in the same event
    CALL Reschedule_Performances_After_Deletion(OLD.Event_ID);
END$$

DELIMITER ;


-- Create trigger: ARTIST CANNOT PRTICIPATE FOR FOUR CONSECUTIVE YEARS
DELIMITER $$

CREATE TRIGGER prevent_fourth_consecutive_year
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE perf_year INT;
    DECLARE consecutive_count INT;

    -- Πάρε το έτος του event στο οποίο πάει να συμμετάσχει ο performer
    SELECT YEAR(Start_Date) INTO perf_year
    FROM Event
    WHERE ID = NEW.Event_ID;

    -- Πόσα από τα προηγούμενα 3 έτη έχει συμμετάσχει ο performer;
    SELECT COUNT(DISTINCT YEAR(e.Start_Date)) INTO consecutive_count
    FROM Performance p
    JOIN Event e ON e.ID = p.Event_ID
    WHERE p.Performer_ID = NEW.Performer_ID
      AND YEAR(e.Start_Date) BETWEEN perf_year - 3 AND perf_year - 1;

    -- Έχει ήδη 3 συνεχόμενα έτη παρουσίας;
    IF consecutive_count = 3 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Ο performer δεν μπορεί να συμμετέχει για 4η συνεχόμενη χρονιά.';
    END IF;
END$$

DELIMITER ;

------------------------------------------------------------------------------------------------------------------
--------------  P R O C E D U R E S ------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------

-- Create procedure: HANDLE DELETION OF PERFORMANCE
DELIMITER $$

CREATE PROCEDURE Reschedule_Performances_After_Deletion(IN deleted_event_id INT)
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE perf_id INT;
    DECLARE perf_type VARCHAR(100);
    DECLARE perf_duration INT;
    DECLARE perf_performer INT;

    DECLARE current_start TIME;
    DECLARE cur CURSOR FOR
        SELECT ID, Type, Duration, Performer_ID
        FROM Performance
        WHERE Event_ID = deleted_event_id
        ORDER BY Start_Time ASC;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    -- Step 1: Delete all performances for this event
    DELETE FROM Performance WHERE Event_ID = deleted_event_id;

    -- Step 2: Get event start time
    SELECT Start_Time INTO current_start
    FROM Event WHERE ID = deleted_event_id;

    -- Step 3: Re-insert performances with 5 min gaps
    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO perf_id, perf_type, perf_duration, perf_performer;
        IF done THEN
            LEAVE read_loop;
        END IF;

        INSERT INTO Performance (ID, Type, Start_Time, Duration, Performer_ID, Event_ID)
        VALUES (
            perf_id, perf_type, current_start, perf_duration, perf_performer, deleted_event_id
        );

        -- Update start time for next performance: current + duration + 5 mins
        SET current_start = ADDTIME(current_start, SEC_TO_TIME(perf_duration * 60 + 5 * 60));
    END LOOP;

    CLOSE cur;
END$$

DELIMITER ;


END$$

DELIMITER ;
