/* DDL ξεκινω να οριζω τις οντοτητες και δε βαζω καθολου κλειδια, μονο τ attributes για αρχη. 
Αυριο θα κανω σε χαρτι το σχημα να δω ποιες σχεσεις περιττευουν και τοτε θα φτιαξω εδω τους 
πινακες των σχεσεων και θα βαλω κλειδια
 */
DROP DATABASE IF EXISTS fest;
CREATE DATABASE fest;
USE fest;

-- Create Location table 
CREATE TABLE Location (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Latitude DECIMAL(9,6) NOT NULL,
    Longitude DECIMAL(9,6) NOT NULL,
    Address VARCHAR(100) NOT NULL,
    City VARCHAR(100) NOT NULL,
    Country VARCHAR(100) NOT NULL,
    Continent VARCHAR(100) NOT NULL,
    UNIQUE (Latitude, Longitude),
    UNIQUE (Address, City, Country, Continent)
);

-- Create Stage table (renamed the second Stage table to Performer_Stage)
CREATE TABLE Stage (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Description VARCHAR(255),
    Capacity INT NOT NULL,
    Tech_Info VARCHAR(255) NOT NULL
);

CREATE TABLE Visitor (
    ID INT PRIMARY KEY,
    First_Name VARCHAR(100),
    Last_Name VARCHAR(100),
    Age INT,
    Con_Info VARCHAR(255)
);

-- Create Festival table
CREATE TABLE Festival (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Start_Date DATE NOT NULL,
    End_Date DATE NOT NULL,
    Location_ID INT NOT NULL,
    UNIQUE (Location_ID),
    UNIQUE (Start_Date),
    FOREIGN KEY (Location_ID) REFERENCES Location(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

-- Create Event table (Removed PERIOD FOR syntax)
CREATE TABLE Event (
    ID INT PRIMARY KEY,
    Start_Time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    End_Time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    Sold_Out BOOLEAN NOT NULL,
    Festival_ID INT NOT NULL,
    Stage_ID INT NOT NULL,
    UNIQUE (Festival_ID, Stage_ID, Start_Time),
    FOREIGN KEY (Festival_ID) REFERENCES Festival(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Stage_ID) REFERENCES Stage(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE Resale_Queue (
    ID INT PRIMARY KEY,
    Activated BOOLEAN,
    Activation_Date DATE,
    Event_ID INT,
    UNIQUE (Event_ID),
    FOREIGN KEY (Event_ID) REFERENCES Event(ID)
);

CREATE TABLE Buy_Queue (
    ID INT PRIMARY KEY,
    Ticket_Category VARCHAR(100),
    Event_ID INT,
    Timestamp DATETIME,
    FOREIGN KEY (Event_ID) REFERENCES Event(ID)
);

-- Create Performer table
CREATE TABLE Performer (
    ID INT PRIMARY KEY,
    Real_Name VARCHAR(100),
    Stage_Name VARCHAR(100) NOT NULL,
    Birthday DATE,
    Instagram VARCHAR(100),
    Website VARCHAR(100),
    Is_Band BOOLEAN NOT NULL,
    Formation_Date DATE
);

CREATE TABLE Performance (
    ID INT PRIMARY KEY,
    Type VARCHAR(100) NOT NULL CHECK (Type IN ('Warm up', 'Head line', 'Special guest')),
    Start_Time TIME NOT NULL,
    Duration INT NOT NULL CHECK (Duration > 0 AND Duration <= 180),
    Performer_ID INT NOT NULL,
    Event_ID INT NOT NULL,
    UNIQUE (Event_ID, Performer_ID),
    FOREIGN KEY (Performer_ID) REFERENCES Performer(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Event_ID) REFERENCES Event(ID) ON DELETE CASCADE ON UPDATE CASCADE
);


-- Create Staff table
CREATE TABLE Staff (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Age INT NOT NULL CHECK (Age > 0),
    Type VARCHAR(100) NOT NULL CHECK (Type IN ('Trainee', 'Beginner', 'Intermediate', 'Experienced', 'Very Experienced'))
);

CREATE TABLE Support_Staff (
    Staff_ID INT PRIMARY KEY,
    FOREIGN KEY (Staff_ID) REFERENCES Staff(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE Security_Staff (
    Staff_ID INT PRIMARY KEY,
    FOREIGN KEY (Staff_ID) REFERENCES Staff(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE Technical_Staff (
    Staff_ID INT PRIMARY KEY,
    FOREIGN KEY (Staff_ID) REFERENCES Staff(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

-- Membership table: Artist is member of Band
CREATE TABLE Membership (
    Band_ID INT NOT NULL,
    Artist_ID INT NOT NULL,
    Join_Date DATE,
    PRIMARY KEY (Band_ID, Artist_ID),
    FOREIGN KEY (Band_ID) REFERENCES Performer(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Artist_ID) REFERENCES Performer(ID) ON DELETE CASCADE ON UPDATE CASCADE
);


-- Create Genre table 
CREATE TABLE Genre (
    ID INT PRIMARY KEY,
    Name VARCHAR(100)
);


-- Optional: Subgenre table
CREATE TABLE Subgenre (
    ID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Genre_ID INT NOT NULL,
    FOREIGN KEY (Genre_ID) REFERENCES Genre(ID) ON DELETE CASCADE ON UPDATE CASCADE
);



-- Optional: Performer's Subgenres (many-to-many)
CREATE TABLE Performer_Subgenre (
    Performer_ID INT NOT NULL,
    Subgenre_ID INT NOT NULL,
    PRIMARY KEY (Performer_ID, Subgenre_ID),
    FOREIGN KEY (Performer_ID) REFERENCES Performer(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Subgenre_ID) REFERENCES Subgenre(ID) ON DELETE CASCADE ON UPDATE CASCADE
);


-- Create event_staff table 
-- (Event is not null even though there is not full participation of staff in the relation.
--  This happens because unemployed staff members are not mentioned in any tupple participating in the relationship,
--  due to on delete cascade constraint. So in order to detect unemployed staff members we simply search for them in 
--  the relationship table.)
CREATE TABLE event_staff (
    Staff_ID INT NOT NULL,
    Event_ID INT NOT NULL,
    PRIMARY KEY (Staff_ID, Event_ID),
    FOREIGN KEY (Staff_ID) REFERENCES Staff(ID) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (Event_ID) REFERENCES Event(ID) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE Type (
    Name VARCHAR(100) PRIMARY KEY
);

CREATE TABLE Payment (
    Name VARCHAR(100) PRIMARY KEY
);

CREATE TABLE Ticket (
    ID INT PRIMARY KEY,
    EAN_URL VARCHAR(200),
    Stage_Info VARCHAR(300),
    Price DECIMAL(10,2),
    Activated BOOLEAN DEFAULT FALSE,
    Date_Bought DATE,
    Type_ID VARCHAR(100),
    Payment_ID VARCHAR(100),
    Event_ID INT,
    UNIQUE (EAN_URL),
    FOREIGN KEY (Type_ID) REFERENCES Type(Name),
    FOREIGN KEY (Payment_ID) REFERENCES Payment(Name),
    FOREIGN KEY (Event_ID) REFERENCES Event(ID)
);

CREATE TABLE Tickets_In_Resale (
    Ticket_ID INT PRIMARY KEY,
    Resale_Queue_ID INT,
    FOREIGN KEY (Ticket_ID) REFERENCES Ticket(ID),
    FOREIGN KEY (Resale_Queue_ID) REFERENCES Resale_Queue(ID)
);

CREATE TABLE Spectator (
    Visitor_ID INT,
    Ticket_ID INT,
    PRIMARY KEY (Visitor_ID, Ticket_ID),
    FOREIGN KEY (Visitor_ID) REFERENCES Visitor(ID),
    FOREIGN KEY (Ticket_ID) REFERENCES Ticket(ID)
);

CREATE TABLE Visitor_Interested_Event (
    Event_ID INT,
    Visitor_ID INT,
    PRIMARY KEY (Event_ID, Visitor_ID),
    FOREIGN KEY (Event_ID) REFERENCES Event(ID),
    FOREIGN KEY (Visitor_ID) REFERENCES Visitor(ID)
);

CREATE TABLE Visitor_Waitlisted (
    Buy_Queue_ID INT,
    Visitor_ID INT,
    PRIMARY KEY (Buy_Queue_ID, Visitor_ID),
    FOREIGN KEY (Buy_Queue_ID) REFERENCES Buy_Queue(ID),
    FOREIGN KEY (Visitor_ID) REFERENCES Visitor(ID)
);

CREATE TABLE Transaction (
    ID INT PRIMARY KEY,
    Is_Resale BOOLEAN,
    Ticket_ID INT,
    Buyer_ID INT,
    UNIQUE (Ticket_ID, Buyer_ID),
    FOREIGN KEY (Ticket_ID) REFERENCES Ticket(ID),
    FOREIGN KEY (Buyer_ID) REFERENCES Visitor(ID)
);

CREATE TABLE Visitor_Sold_Ticket (
    Seller_ID INT,
    Ticket_ID INT,
    Transaction_ID INT,
    PRIMARY KEY (Seller_ID, Ticket_ID),
    FOREIGN KEY (Seller_ID) REFERENCES Visitor(ID),
    FOREIGN KEY (Ticket_ID) REFERENCES Ticket(ID),
    FOREIGN KEY (Transaction_ID) REFERENCES Transaction(ID)
);

CREATE TABLE Review (
    ID INT PRIMARY KEY AUTO_INCREMENT,
    Interpretation INT,
    Sound INT,
    Lighting INT,
    Stage_Presence INT,
    Organization INT,
    Overall INT,
    Ticket_ID INT,
    UNIQUE (Ticket_ID),
    FOREIGN KEY (Ticket_ID) REFERENCES Ticket(ID)
);

-------------------------------------------------------------------------------------------------------------------
---------------------   T R I G G E R S ---------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------

-- Create trigger: FESTIVAL CANNOT BE CANCELDED
DELIMITER $$

CREATE TRIGGER prevent_festival_cancellation
BEFORE UPDATE ON Festival
FOR EACH ROW
BEGIN
    -- Prevent the cancellation of festivals
    IF OLD.End_Date IS NOT NULL AND NEW.End_Date IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Festivals cannot be canceled.';
    END IF;
END $$

DELIMITER ;


-- Create trigger: EVENT CANNOT BE CANCELLED
DELIMITER $$

CREATE TRIGGER prevent_event_cancellation
BEFORE UPDATE ON Event
FOR EACH ROW
BEGIN
    -- Prevent the cancellation of events
    IF NEW.Sold_Out = FALSE AND OLD.Sold_Out = TRUE THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Events cannot be canceled once they are marked as sold out.';
    END IF;
END $$

DELIMITER ;


-- Create trigger: BAND CANNOT BE MEMBER OF BAND
DELIMITER $$

CREATE TRIGGER prevent_band_as_member
BEFORE INSERT ON Membership
FOR EACH ROW
BEGIN
    DECLARE is_band_member BOOLEAN;

    -- Check if the performer being added as a member is a band
    SELECT Is_Band INTO is_band_member
    FROM Performer
    WHERE ID = NEW.Artist_ID;

    -- If the member is a band, prevent the insertion
    IF is_band_member = TRUE THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'A band cannot be a member of another band.';
    END IF;
END$$

DELIMITER ;


-- Create trigger for INTERVALS (from 5 to 30 mins) 
-- between consecutive performances of the same event
DELIMITER $$

CREATE TRIGGER check_performance_break
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE last_end_time TIME;
    DECLARE time_diff INT;

    -- Get the end time of the last performance in the event for the same stage
    SELECT End_Time INTO last_end_time
    FROM Performance
    WHERE Event_ID = NEW.Event_ID
      AND Performer_ID != NEW.Performer_ID
    ORDER BY End_Time DESC LIMIT 1;

    -- If a performance already exists, check the time difference
    IF last_end_time IS NOT NULL THEN
        SET time_diff = TIMESTAMPDIFF(MINUTE, last_end_time, NEW.Start_Time);

        -- Check if the break is between 5 and 30 minutes
        IF time_diff < 5 OR time_diff > 30 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'There must be a break between 5 and 30 minutes between performances.';
        END IF;
    END IF;
END $$

DELIMITER ;


-- Create trigger: NO OVERLAP OF EVENTS AT THE SAME STAGE
DELIMITER $$

CREATE TRIGGER prevent_stage_overlap
BEFORE INSERT ON Event
FOR EACH ROW
BEGIN
    DECLARE overlap_found INT;

    -- Check for overlap
    SELECT COUNT(*)
    INTO overlap_found
    FROM Event p
    WHERE p.Stage_ID = NEW.Stage_ID
      AND (
           (NEW.Start_Time BETWEEN p.Start_Time AND p.End_Time)
        OR (NEW.End_Time BETWEEN p.Start_Time AND p.End_Time)
        OR (p.Start_Time BETWEEN NEW.Start_Time AND NEW.End_Time)
        OR (p.End_Time BETWEEN NEW.Start_Time AND NEW.End_Time)
      );

    -- If overlap is found, signal an error
    IF overlap_found > 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Stage already occupied during this time.';
    END IF;
END $$

DELIMITER;


-- Create trigger: NO DOUBLE BOOKING OF PERFORMERS
DELIMITER $$

CREATE TRIGGER prevent_overlapping_performances
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE new_start TIME;
    DECLARE new_end TIME;

    SET new_start = NEW.Start_Time;
    SET new_end = ADDTIME(NEW.Start_Time, SEC_TO_TIME(NEW.Duration * 60));

    -- 1. Same performer overlap check
    IF EXISTS (
        SELECT 1
        FROM Performance p
        WHERE p.Performer_ID = NEW.Performer_ID
          AND p.Event_ID != NEW.Event_ID
          AND (
                (new_start BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (new_end BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (p.Start_Time BETWEEN new_start AND new_end)
             OR (ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)) BETWEEN new_start AND new_end)
          )
    ) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Performer is already in a performance during this time.';
    END IF;

    -- 2. Artist’s bands overlap
    IF EXISTS (
        SELECT 1
        FROM Membership m
        JOIN Performance p ON p.Performer_ID = m.Band_ID
        WHERE m.Artist_ID = NEW.Performer_ID
          AND (
                (new_start BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (new_end BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (p.Start_Time BETWEEN new_start AND new_end)
             OR (ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)) BETWEEN new_start AND new_end)
          )
    ) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'One of the performer’s bands is already performing during this time.';
    END IF;

    -- 3. Band member overlap
    IF EXISTS (
        SELECT 1
        FROM Membership m
        JOIN Performance p ON p.Performer_ID = m.Artist_ID
        WHERE m.Band_ID = NEW.Performer_ID
          AND (
                (new_start BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (new_end BETWEEN p.Start_Time AND ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)))
             OR (p.Start_Time BETWEEN new_start AND new_end)
             OR (ADDTIME(p.Start_Time, SEC_TO_TIME(p.Duration * 60)) BETWEEN new_start AND new_end)
          )
    ) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'A member of the band is already performing during this time.';
    END IF;
END $$

DELIMITER ;


-- Create trigger: AFTER DELETION OF PERFRORMANCE
DELIMITER $$

CREATE TRIGGER after_performance_delete
AFTER DELETE ON Performance
FOR EACH ROW
BEGIN
    -- Call the procedure to reschedule performances in the same event
    CALL Reschedule_Performances_After_Deletion(OLD.Event_ID);
END$$

DELIMITER ;


-- Create trigger: ARTIST CANNOT PRTICIPATE FOR FOUR CONSECUTIVE YEARS
DELIMITER $$

CREATE TRIGGER prevent_fourth_consecutive_year
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE perf_year INT;
    DECLARE consecutive_count INT;

    -- Πάρε το έτος του event στο οποίο πάει να συμμετάσχει ο performer
    SELECT YEAR(Start_Date) INTO perf_year
    FROM Event
    WHERE ID = NEW.Event_ID;

    -- Πόσα από τα προηγούμενα 3 έτη έχει συμμετάσχει ο performer;
    SELECT COUNT(DISTINCT YEAR(e.Start_Date)) INTO consecutive_count
    FROM Performance p
    JOIN Event e ON e.ID = p.Event_ID
    WHERE p.Performer_ID = NEW.Performer_ID
      AND YEAR(e.Start_Date) BETWEEN perf_year - 3 AND perf_year - 1;

    -- Έχει ήδη 3 συνεχόμενα έτη παρουσίας;
    IF consecutive_count = 3 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Ο performer δεν μπορεί να συμμετέχει για 4η συνεχόμενη χρονιά.';
    END IF;
END$$

DELIMITER ;


-- Create trigger: STAFF MUST NOT BE INSUFFICIENT
DELIMITER $$

CREATE TRIGGER trg_autofill_staff_after_spectator_insert
AFTER INSERT ON Spectator
FOR EACH ROW
BEGIN
    DECLARE event_id INT;

    SELECT Event_ID INTO event_id
    FROM Ticket
    WHERE ID = NEW.Ticket_ID;

    CALL AutoAssignStaff(event_id);
END;
//

CREATE TRIGGER trg_autofill_staff_after_spectator_delete
AFTER DELETE ON Spectator
FOR EACH ROW
BEGIN
    DECLARE event_id INT;

    SELECT Event_ID INTO event_id
    FROM Ticket
    WHERE ID = OLD.Ticket_ID;

    CALL AutoAssignStaff(event_id);
END;
//

DELIMITER ;

------------------------------------------------------------------------------------------------------------------
--------------  P R O C E D U R E S ------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------

-- Create procedure: HANDLE DELETION OF PERFORMANCE
DELIMITER $$

CREATE PROCEDURE Reschedule_Performances_After_Deletion(IN deleted_event_id INT)
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE perf_id INT;
    DECLARE perf_type VARCHAR(100);
    DECLARE perf_duration INT;
    DECLARE perf_performer INT;

    DECLARE current_start TIME;
    DECLARE cur CURSOR FOR
        SELECT ID, Type, Duration, Performer_ID
        FROM Performance
        WHERE Event_ID = deleted_event_id
        ORDER BY Start_Time ASC;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    -- Step 1: Delete all performances for this event
    DELETE FROM Performance WHERE Event_ID = deleted_event_id;

    -- Step 2: Get event start time
    SELECT Start_Time INTO current_start
    FROM Event WHERE ID = deleted_event_id;

    -- Step 3: Re-insert performances with 5 min gaps
    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO perf_id, perf_type, perf_duration, perf_performer;
        IF done THEN
            LEAVE read_loop;
        END IF;

        INSERT INTO Performance (ID, Type, Start_Time, Duration, Performer_ID, Event_ID)
        VALUES (
            perf_id, perf_type, current_start, perf_duration, perf_performer, deleted_event_id
        );

        -- Update start time for next performance: current + duration + 5 mins
        SET current_start = ADDTIME(current_start, SEC_TO_TIME(perf_duration * 60 + 5 * 60));
    END LOOP;

    CLOSE cur;
END$$

DELIMITER ;


--Create procedure that validates staff coverage and autoassigns more staff if neeeded
DELIMITER $$

CREATE PROCEDURE AutoAssignStaff(IN p_Event_ID INT)
BEGIN
    DECLARE v_TotalSpectators INT DEFAULT 0;
    DECLARE v_RequiredSecurity INT DEFAULT 0;
    DECLARE v_RequiredSupport INT DEFAULT 0;
    DECLARE v_CurrentSecurity INT DEFAULT 0;
    DECLARE v_CurrentSupport INT DEFAULT 0;

    -- Get number of spectators
    SELECT COUNT(*) INTO v_TotalSpectators
    FROM Spectator S
    JOIN Ticket T ON S.Ticket_ID = T.ID
    WHERE T.Event_ID = p_Event_ID;

    -- Calculate required staff
    SET v_RequiredSecurity = CEIL(0.05 * v_TotalSpectators);
    SET v_RequiredSupport = CEIL(0.02 * v_TotalSpectators);

    -- Get current counts
    SELECT COUNT(*) INTO v_CurrentSecurity
    FROM event_staff es
    JOIN Security_Staff ss ON es.Staff_ID = ss.Staff_ID
    WHERE es.Event_ID = p_Event_ID;

    SELECT COUNT(*) INTO v_CurrentSupport
    FROM event_staff es
    JOIN Support_Staff ss ON es.Staff_ID = ss.Staff_ID
    WHERE es.Event_ID = p_Event_ID;

    -- Assign additional security staff if needed
    WHILE v_CurrentSecurity < v_RequiredSecurity DO
        INSERT INTO event_staff (Staff_ID, Event_ID)
        SELECT ss.Staff_ID, p_Event_ID
        FROM Security_Staff ss
        WHERE ss.Staff_ID NOT IN (
            SELECT Staff_ID FROM event_staff WHERE Event_ID = p_Event_ID
        )
        LIMIT 1;

        SET v_CurrentSecurity = v_CurrentSecurity + 1;
    END WHILE;

    -- Assign additional support staff if needed
    WHILE v_CurrentSupport < v_RequiredSupport DO
        INSERT INTO event_staff (Staff_ID, Event_ID)
        SELECT ss.Staff_ID, p_Event_ID
        FROM Support_Staff ss
        WHERE ss.Staff_ID NOT IN (
            SELECT Staff_ID FROM event_staff WHERE Event_ID = p_Event_ID
        )
        LIMIT 1;

        SET v_CurrentSupport = v_CurrentSupport + 1;
    END WHILE;
END;
//

DELIMITER ;

